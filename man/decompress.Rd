% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{decompress}
\alias{decompress}
\title{Decompress a compressed raw vector using zlib}
\usage{
decompress(x, wbits = 15L)
}
\arguments{
\item{x}{the compressed raw vector}

\item{wbits}{a parameter that controls the window size and type of header/trailer used.
Default is 15. See Details for more information.}
}
\value{
a raw vector.
}
\description{
Decompress a compressed raw vector using zlib
}
\section{wbits parameter}{


The windowBits parameter is the base two logarithm of the maximum window
size (the size of the history buffer).  It should be in the range 8..15 for
this version of the library. The default value is 15 if inflateInit is used
instead. windowBits must be greater than or equal to the windowBits value
provided to deflateInit2() while compressing, or it must be equal to 15 if
deflateInit2() was not used. If a compressed stream with a larger window
size is given as input, inflate() will return with the error code
Z_DATA_ERROR instead of trying to allocate a larger window.
   
windowBits can also be -8..-15 for raw inflate. In this case, -windowBits
determines the window size. inflate() will then process raw deflate data,
not looking for a zlib or gzip header, not generating a check value, and not
looking for any check values for comparison at the end of the stream. This
is for use with other formats that use the deflate compressed data format
such as zip.  Those formats provide their own check values. If a custom
format is developed using the raw deflate format for compressed data, it is
recommended that a check value such as an adler32 or a crc32 be applied to
the uncompressed data as is done in the zlib, gzip, and zip formats.  For
most applications, the zlib format should be used as is. Note that comments
above on the use in deflateInit2() applies to the magnitude of windowBits.
           
windowBits can also be greater than 15 for optional gzip decoding. Add
32 to windowBits to enable zlib and gzip decoding with automatic header
detection, or add 16 to decode only the gzip format (the zlib format will
return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is
a crc32 instead of an adler32.
}

